import Profile from './components/Profile';

// 전역변수처럼 여러 컴포넌트가 동일한 디자인을 가지고 싶을 경우에는 App(메인화면)에서 디자인하면 좋다!
import './App.css';

function App() {
  return (
    <>
      <Profile
        image=''
        name='James Kim'
        title='프론트엔드 개발자'
        isNew={true}
      />
      {/* 
        왜 true만 중괄호? 
        문자열은 중괄호 없이 '문자열'로 전달해도 되지만, 'true'(문자열)로 보낼 시, 타입이 달라져서 의미도 달라질 수 있음!
        숫자나 boolean(true/false) 등의 변수들은 반드시 중괄호를 달아주어야 한다.
         */}
    </>
  );
}

export default App;

/**
 * App: 여러개의 컴포넌트를 묶어주는 메인화면
 * main.jsx : App에서 만들어진 태그를 root에 끼워주는 것
 *
 * 리액트는 기본적으로 클라이언트에서 웹 페이지를 만들어서 보여줌
 *  => 클라이언트 랜더링
 * 브라우저에서 리액트 코드가 실행 -> HTML요소를 동적으로 생성 -> 화면 생성
 *
 * 처음 index.html 파일만 서버에서 다운로드 받고, 그 이후의 화면구성은 React코드로 처리됨
 *
 * 랜더링?
 *  - 웹페이지를 화면에 보여준다
 *
 * 리랜더링?
 *  - 다시 화면 그리기
 *
 * 리액트 동작 방식 => 가상 DOM(Virtual DOM)
 *  - 리액트는 매번 화면 전체를 바꾸지 않는다(새로고침이 일어나지 않음)
 *  - 눈에 보이는 화면을 복사해서 숨겨 놓고, 바뀌는 부분만 실제 화면에 반영한다.
 *    => 최소한의 업데이트만 진행
 *  - DOM의 복사본을 메모리상에 만든다(js 객체 트리)
 *  - DOM의 복사본과 실제 돔을 비교
 *  - Reconciliation 알고리즘을 사용하여 특정 key값으로 DOM 요소를 추적
 *
 * 리액트에서 컴포넌트를 만드는 방식 (간단하게)
 * 1. 함수형 컴포넌트
 *   - 단순히 함수로 UI를 정의하고 useState, useEffect 같은 Hooks로 상태나 생명 주기 기능을 사용 가능
 *   - 데이터를 전달받을 때, props를 전달해주면 된다(간단)
 *
 * 2. 클래스 컴포넌트
 *   - ES6클래스 문법을 사용하며 상태관리 시, this.state, 객체를 만들어 사용
 *   - 객체 지향느낌이 강함!
 * (객체를 나타내는 this->이게 어느 객체를 나타내는지 몰라서 요즘은 잘 안쓴다고...)
 *   - 데이터를 전달받을 때, constructor(props)를 사용하여 전달받음
 *      - 만약 constructor을 사용하고 데이터를 전달안하면 에러남ㅠㅠ
 *   - 클래스 컴포넌트는 라이브러리나 옛날 코드들에서 확인할 수 있다.
 *
 *
 * ✅ 요약!
 * 가상돔을 이용해서 리액트가 전체 화면을 그리지 않고, 새로고침 하지 않고, 변경된 부분만 빠르게 수정
 * 클래스 컴포넌트는 복잡해서 함수형 컴포넌트를 많이 사용하는 추세이다!!
 *
 *
 *

 * ----
 * 인터넷은 IP로 구성되어있다. 하지만 IP주소는 너무 어려우니 도메인(글자)로 나타낸다.
 * 이전에는 html문서등을 서버에서 저장해서 불러오는 방식을 썼었다.
 * 요즘은 동적으로 표현하기위해 리액트 등을 사용함
 * ----
 *
 *
 */
