# [Day22] 25.06.10 배운내용 정리

---

### 🔗 프로젝트 소개

- [day22-react](./day22-react/)
  - 한 페이지에서 컴포넌트 여러개로 분리하는 실습
- [day22-react-2](./day22-react-2/)
  - 이벤트 주는 실습

---

# 🧩 리액트 기본 구조

### ✅ App.jsx

> 여러 컴포넌트를 묶어주는 메인 화면 역할

### ✅ main.jsx

> App에서 만든 태그를 HTML의 root 요소에 끼워 넣는 파일

---

# 🌐 리액트의 렌더링 방식

### 🔄 클라이언트 렌더링

- 리액트는 브라우저(클라이언트) 에서 웹 페이지를 만들어서 보여줌
- 서버에서는 처음에 index.html 파일만 다운로드
- 이후 화면 구성은 리액트 코드가 처리

### 🖼️ 렌더링 vs 리렌더링

- 렌더링: 웹페이지를 화면에 처음 보여주는 것
- 리렌더링: 상태(state) 변화 등으로 인해 다시 화면을 그리는 것

---

# 🧠 리액트의 핵심: 가상 DOM (Virtual DOM)

### ✅ 동작 방식

- 전체 화면을 바꾸지 않음 (새로고침 ❌)
- 실제 DOM의 복사본(Virtual DOM) 을 메모리에 보관
- 변경 전후의 가상 DOM을 비교
- 변경 전후의 가상 DOM을 비교
- 변경된 부분만 실제 DOM에 반영
- Reconciliation 알고리즘으로 변경을 최적화
  - → 특정 key 값을 이용하여 DOM 요소 추적

---

# 🧱 컴포넌트 만들기

#### 1. 함수형 컴포넌트 (Functional Component)

- 단순한 함수 형태로 UI 정의
- useState, useEffect 등 Hooks 사용 가능
- 데이터는 props로 전달받음

#### 2. 클래스 컴포넌트 (Class Component)

- ES6 클래스 문법 사용
- 상태는 this.state 로 관리
- 데이터는 constructor(props)로 전달
  - → 전달하지 않으면 에러 발생할 수 있음
- 요즘은 잘 사용하지 않음
  - → this 바인딩 이슈, 복잡한 구조 등 이유
- 🔎 클래스 컴포넌트는 주로 옛날 코드나 일부 라이브러리에서 볼 수 있다!

### 🧐 왜 컴포넌트를 나누나요?

- 재사용을 위해 따로 컴포넌트 제작
- UI가 변경이 되더라도 부분만 수정이 가능함 (확장성 good!)
- 예시: 아바타 이미지는 여러곳에서 사용될 수 있다!

---

# 🧪 `useState` Hook 개념 정리

> Hooks : 함수형 컴포넌트에서는 상태나 생명주기를 사용할 수 있게 도와주는 도구

## `useState` 란?

```js
const [state, setState] = useState(0);
```

- 상태(state) 는 컴포넌트가 기억해야 할 값
- 상태가 변경되면 → 해당 컴포넌트는 자동으로 리렌더링됨
- 일반 변수와 달리, React는 useState로 만든 값을 감지하고 추적함

### 동작하는 방식

1. 컴포넌트가 처음 렌더링
   - `[0,setState]`을 반환한다 -> 리액트는 0을 최신 state값으로 기억
2. `state` 업데이트
   - 사용자가 버튼을 클릭하면 `setIndex()`함수를 호출
   - 리액트에 `state` 값이 1임을 기억하게 한다.

#### 위 코드에서의 상태

- `count`: 클릭 수를 저장하는 상태
- `setCount`: `count`를 변경하는 함수
- `name`: 이름 상태
- `setName`: 이름을 변경하는 함수

### 🧨 일반 변수로 처리했을 경우의 문제점

```js
let count = 0;

function click() {
  count++;
}
```

- 일반 변수는 React가 감지하지 않음
- 따라서 화면(UI)은 업데이트되지 않음
- 이유:
  - 일반 변수는 메모리에서만 변경됨
  - 리액트는 state의 변화만 감지하여 리렌더링을 수행함

> ⚠️ React에서 화면에 영향을 주는 값은 반드시 state로 관리해야 함!

---

## 📘 JSX 코드 설명 정리

### 📦 import 구문

```js
import Profile from './components/Profile';
import './App.css';
```

- `Profile` 컴포넌트를 import
- 전체 애플리케이션에서 공통된 스타일이 필요할 경우, `App.css`에서 **전역 스타일**을 관리하는 것이 좋음

### 🧩 App 컴포넌트 정의

```js
function App() {
  return (
    <>
      <Profile
        image=''
        name='James Kim'
        title='프론트엔드 개발자'
        isNew={true}
      />
    </>
  );
}
```

- `App`은 리액트 애플리케이션의 **메인 컴포넌트**
- `Profile` 컴포넌트에 **props**를 전달하여 사용자 정보를 표시함

### 🧠 Props 전달 시 주의사항

```js
<Profile image='' name='James Kim' title='프론트엔드 개발자' isNew={true} />
```

- 문자열 `props` (`name`, `title`) 는 그냥 문자열로 전달 가능
  ```js
  name = 'James Kim';
  ```
- `boolean`, `number`, `object` 등 문자열이 아닌 타입은 반드시 중괄호 {} 로 감싸야 함
  ```js
  isNew={true}
  ```
  > ⚠️ isNew='true' 이렇게 문자열로 전달하면 "true"라는 문자열이 되어서 실제 boolean true와는 완전히 다른 의미가 될 수 있음!

<!-- 여기에 day22-react-2의 내용 추가 -->

### 🖱️ 마우스 이벤트와 객체 상태 관리

#### ✅ onPointerMove 이벤트로 마우스 좌표 추적하기

- 마우스를 움직일 때 좌표를 추적하여 상태로 관리하고,
- `transform` 속성을 활용해 빨간 점이 마우스를 따라다니도록 구현

```js
onPointerMove={(e) => {
  setPosition({
    x: e.clientX,
    y: e.clientY,
  });
}}
```

- `position` 상태는 `{ x: 0, y: 0 }` 형식의 객체
- `transform`: `translate(x, y)` 로 위치 이동 구현
- 🔺 마우스 이벤트에는 `onPointerMove`를 자주 사용 (보다 범용적인 이벤트)

##### 💡 실습 포인트

- **마우스 이벤트 + 객체 상태 + transform 스타일**
- `useState`로 객체를 관리할 때도 전체 객체를 덮어쓰므로 **부분 수정 시 반드시 기존 값을 복사 후 병합**

#### ✅ 입력값 상태를 객체로 관리하기 (UseObject 예제)

```js
const [user, setUser] = useState({
  name: '',
  job: '',
});
```

- 여러 개의 input 상태를 객체 하나로 통합해서 관리 가능

```js
onChange={(e) => {
setUser({ ...user, name: e.target.value });
}}
```

- `...user`: 기존 객체 내용을 복사한 후, 특정 필드만 덮어씀
- 이유:
  - React는 객체의 **부분 업데이트**를 자동으로 하지 않음
  - 스프레드 문법을 사용하지 않으면 다른 필드 값이 **날아갈 수 있음**

> ⚠️ 리액트의 상태 업데이트는 기존 값 보존 + 필요한 값만 수정이 기본 전략

---

## ✅ 요약 정리

- **가상 DOM** 덕분에 전체 화면을 다시 그리지 않고 **변경된 부분만 빠르게 수정**
- **함수형 컴포넌트**는 간결하고 **Hooks**를 활용할 수 있어 현재 더 널리 사용됨
  - → 클래스 컴포넌트보다 코드가 직관적이며 유지보수에 유리
- **`Props`**를 통해 컴포넌트 간 데이터를 전달할 수 있으며,
- 문자열 외의 값(`boolean`, `number` 등)은 반드시 `{}` 중괄호로 감싸야 함
- **컴포넌트 분리**는 재사용성, 유지보수성, 확장성을 높여주는 핵심 전략
- **`useState`**를 사용하면 컴포넌트 내부에서 값을 **기억**하고 상태 변경 시 **리렌더링을 유도**할 수 있음
  - 일반 변수(`let`, `const`)는 리렌더링을 유도하지 않음 → _화면(UI)에는 반영되지 않음_
  - 상태는 반드시 `useState`로 관리해야 React가 변화를 감지할 수 있음
- React는 **state** 기반 **UI 업데이트 시스템**을 사용
  - → 상태가 변할 때만 화면을 **자동으로 새로 그려줌**

---

### 🌍 참고: 인터넷의 작동 방식

> - 인터넷은 IP 주소 기반으로 구성됨
> - 하지만 IP는 외우기 어려워서 → 도메인 이름 사용
>
> > - 과거: 서버에서 저장된 정적인 HTML 문서를 받아오는 방식
> > - 현재: React 등을 사용해 동적으로 화면 구성
