# \[Day 37] — 2025.07.01 배운 내용 정리

---

## Big-O 표기법 (Big-O Notation)

- 코드가 크게 되고 데이터가 더 많아지면, 성능이 어떻게 느릴지에 대한 힌트
- 아래의 O 표기법은 입력 크기(n)에 따라 시간과 메모리 사용량이 어떻게 증가하는지 보여줍니다.

### 표기 `O`

- `Order of` 의 줄임마다.
- 알고리즘의 성장 속도 (보기 리턴)을 수학적으로 표현.

---

## Big-O 범위별 설명

### O(1) — 일정

- 입력 크기와 상관없이 딱 한번에 끝나는 연산
- 예)
  - 모달 열기
  - 다크모드 방지
  - 로그인 검사

### O(n) — 선형

- 입력 크기만큼 반복
- n = 데이터 개수
- 프론트에서는 리스트 렌더링, 검색 필터, 총합 계산 등에서 자주 사용
- 예)
  - 리스트 렌더링
  - 검색 필터
  - 총합 계산

### O(n^2) — 이중 반복

- 중첩 반복문
- n² 은 n \* n 번의 실행을 의미
- 예) n = 10 일 경우, 100 번 실행
- 큰 데이터에서는 매우 빠른 성능 처리 가능

### O(log n), O(n log n)

- 검색 방식이 동기적 개발을 하면 복잡도가 줄어들수 있다
- 예)
  - O(log n): 이진 검색
  - O(n log n): 병합 정렬, 퀵정렬, 힙 정렬

---

## 시간 복잡도 (Time Complexity)

- 입력 크기가 증가할 경우 시간적으로 어떻게 소요되는지 보여준다.
- 시간 복잡도는 느려지기 전에 예방하는 속도 가이드 라인
- `performance.now()` 를 사용하여 시간 복잡도를 확인할 수 있다.

### performance.now()

- 페이지가 로드되어 시작된 후에서 경과시간을 미리초(6자리)로 반환
- `start`, `end`를 이용해 개별 코드 블록의 시간차 계산 가능

```js
const start = performance.now();
const sum = numA + numB;
const end = performance.now();
```

---
