# [Day38] 25.07.02 학습내용 정리

---

## 시간복잡도 & 공간 복잡도

### 시간복잡도

- 코드의 속도 측정
- 최악의 경우 모든 데이터를 끝까지 확인하기 때문에 O(n)

---

### 공간복잡도

- 코드가 얼마나 많은 메모리를 사용하는지 측정하는 방법
  - 코드의 메모리 사용량을 측정
- 추가 메모리 사용을 하지 않고, 단 하나의 변수만 사용하기 때문에 O(1)

---

## Big-O 표기법 종류\_2

### O(log2n) 로그 시간 복잡도

- 입력값의 크기가 커질 수록 실행 시간이 로그만큼 짧아지는 알고리즘
- n이 증가해도 실행 시간이 느리게 증가하는 알고리즘
- 즉 데이터가 반씩 잘려나간다.
- 대표적으로 이진탐색

  - 단 이진 탐색은 무조건 정렬이 되어있어야하는 조건이 따름

    lodash : 대표적인 이진트리 라이브러리
    `npm install lodash`
    배열, 객체, 문자열 등을 쉽고 빠르게 처리할 수 있는 함수들이 많음
    성능 최적화된 함수들이 많아서 복잡한 작업을 간단하게 만들어줄 수 있다.

---

### On(log2n) 선형 로그 시간 복잡도

- 한번 전체 순회(n) 하면서 그 안에서 또 반씩 줄이는 (log n) 작업을 반복할 때
  발생하는 시간 복잡도
- 정렬 알고리즘 (병합 정렬, 퀵 정렬)에서 등장하고 n이 커져도 n2보다 훨씬 효율적으로
  정렬할 수 있다
- 데이터를 쪼개고-> 정렬하고-> 합치는 분할 정복 방식에서 자주 사용한다

- 병합정렬 기준

  - 배열의 중간(mid) 인덱스(index)
  - 배열을 계속 반으로 나누며 기준이 바뀜
  - 병합할 때는 항상 작은 수부터 비교해서 넣음

- 순서 정리
  - 배열의 개수가 1개가 될 때까지 나눈다
  - 쌍(pair)끼리 비교해서 정렬
  - 정렬된 쌍들을 차례대로 합침
  - 최종적으로 전체가 정렬된다

---

### O(2n) 지수 시간 복잡도

- 재귀호출로 모든 경우의 수를 탐색할 때 사용
- 대표적인 예 : 피보나치

---

### O(n!) 팩토리얼 시간 복잡도

- 순열이나 조합 알고리즘에서 등장

---

## 최적화 할 때 고려할 알고리즘 복잡도 순서

> O(1) -> O(log n) -> O(n) => O(n log n) -> O(n^2) -> O(2n) -> O(n!)

_작은 계산은 표기를 거의 하지 않음 = 싱수(고정된 값) 다 무시되어 단순하게 표시함_

| 표현식          | Big-O 표기 |
| --------------- | ---------- |
| O(n + 10)       | O(n)       |
| O(1000n + 50)   | O(n)       |
| O(n^2 + 5n + 8) | O(n^2)     |

---

## 실습!

#### 문제: 빅오 표기법 사용해보기

| 문제         | 실제 표기(내가입력) | 실제 표기 (답안) |
| ------------ | ------------------- | ---------------- |
| O(100 \* n)  | O(n)                | O(n)             |
| O(25)        | O(1)                | O(1)             |
| O(n^2 + n^3) | O(n^2)              | **O(n^3)**       |
| O(n+n+n+n)   | O(4n)               | **O(n)**         |

- O(n^2 + n^3) -> 가장 높은 차수의 항만 남겨야 함
- O(n+n+n+n) -> O(4n) -> 상수는 무시 -> O(n)
