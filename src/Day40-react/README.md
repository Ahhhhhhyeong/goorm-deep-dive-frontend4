# [Day40] 25.07.04 배운 내용 정리

---

## ♻️ 동적 프로그래밍(Dynamic Programming - DP)

- 중복 부분 문제와 최적 부분 구조를 가지는 문제를 해결
- 작은 문제부터 차례대로 풀어서 그 결과를 저장(메모이제이션 또는 테이블 채우기)
- 이후 같은 문제가 다시 필요할 때 저장된 값을 활용해 불필요한 연산을 제거하는 기법
- 즉, 한번 푼 문제들을 저장해 두었다가 재사용함으로써 전체 계산량을 줄이는 것
  => 내가 푼 문제들을 메모장에 적어두기 전략

#### 🤷 DP를 왜 사용하는가?

> 재귀적으로 계속 호출하게 되면 심한 중복을 일어난다

- 리엑트에서는 성능 최적화, 캐싱, 데이터 처리 최적화 자주 활용됨
  => useMemo, useCallBack, React Query 캐시 등
- 백엔드와의 통신에서는 중복 요청을 줄이거나 결과 재활용하는 개념으로 사용됨

---

### 🔎 LCS 알고리즘

> 문자열 혹은 배열 내에서 가장 긴 공통 부분 수열을 찾는 알고리즘
>
> 다이나믹 프로그래밍(DP) 기반의 알고리즘
>
> > 주로 문자나 코드 비교 도구, 버전관리 시스템에 응용된다

---

### 🌲 피보나치 수열

> 재귀와 DP를 비교하며 피보나치 수열 만들기

#### 🎯 재귀 활용

```js
const fibo = (n) => {
  if (n == 0 || n == 1) return n;
  else {
    return fibo(n - 1) + fibo(n - 2);
  }
};
```

- 재귀를 사용하면 같은 연산이 불필요하게 많이 호출된다.
  => n = 5일 때, f(3)은 2회, f(2)는 3회 f(1)은 5회, f(0)은 3회 호출
- 시간복잡도 : O(2^n)

#### 🎯 DP 활용

```js
const fibo = (n) => {
  if (n == 0 || n == 1) return n;
  else {
    const arr = Array(n + 1).fill(0);
    arr[0] = 0;
    arr[1] = 1;

    for (let i = 2; i <= n; i++) {
      arr[i] = arr[i - 1] + arr[i - 2];
    }
    return arr;
  }
};
```

- 시간복잡도 = O(n)
- 재귀호출에 비해 수행시간이 빠르고, n의 값이 커질수록 반복문이 빠르다는 것을 알 수 있다.
  - 만약 n = 50이면
  - 재귀 호출에서 2^50(1,125,899,906,842,624)번 연산을 할 때,
  - 반복문은 50번만 연산하면 된다.
- 하지만 하노이탑 문제에서는 반복문으로 풀기 복잡해져 재귀 함수를 많이 사용하는 편이다.

---

## 📍 Map 자료형

- 키가 있는 데이터를 저장한다는 점에서 객체와 유사하지만, 맵은 key에 다양한 자료형을 허용한다
- 맵은 키의 타입을 반환하지 않고 그대로 유지한다

```js
let obj = { a: 1, b: 2 };
// obj : {"a":"1", "b":"2"}
let map1 = new Map([
  ['a', 1],
  ['b', 2],
]);
// map1 : {"a" => 1, "b" => 2}
```

### Map 자료형 메서드

| Method               | 설명                                               |
| -------------------- | -------------------------------------------------- |
| `new Map()`          | 새로운 맵 생성                                     |
| `map.set(key,value)` | key를 이용해 vlaue를 저장                          |
| `map.get(key)`       | key에 해당하는 값을 반환(없으면 undefinded)        |
| `map.has(key)`       | key가 존재하면 true, 존재하지 않으면 false         |
| `map.delete(key)`    | key에 해당하는 값을 삭제                           |
| `map.clear()`        | 맵 안의 모든 요소를 제거                           |
| `map.size`           | 요소의 개수를 반환                                 |
| `forEach`            | 각 요소에 대해 주어진 함수를 실행                  |
| `keys()`             | 맵의 모든 키를 반복 가능한 객체로 반환             |
| `values()`           | 맵의 모든 값을 반복 가능한 객체로 반환             |
| `entires()`          | [키,값] 쌍의 배열로 이루어진 반복 가능한 객체 반환 |

---
