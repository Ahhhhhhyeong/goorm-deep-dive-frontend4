# [Day45] 25.07.11 배운내용 정리

---

## Zustand + MiddleWare

> ### 🤔 대규모 앱으로 가면 추가적으로 생각해야되는 문제

1. 도메인(Feature) 단위 폴더링
   - 예: `features/todo/{components, stores, types, ...}` 구조로 기능별로 분리
2. 타입스크립트 적용
   - `strict` 모드 등 엄격한 타입 지정으로 안정성과 예측 가능성 향상
3. 미들웨어 활용
   - 로컬스토리지 동기화, 불변성관리(immer), devtools 연동 등 상태 관리 기능 확장
4. API 연동
   - React Query나 Axios 인터셉터와 결합하여 서버 상태 관리 통합

---

### 🧩 미들웨어란?

> **상태 관리(Store)**와 **앱의 실제 사용 코드 사이에서** 동작하는 **부가 기능 레이어**

- Zustand에서는 미들웨어를 활용해 **상태 저장, 상태 추적, 불변성 유지 등 부가기능**을 손쉽게 추가할 수 있음
- 대표적으로 쥬드텐드를 사용할 때 예를 들면 3가지 기능이 있다.

---

#### 1. `persist` - 로컬스토리 동기화

- **상태를 브라우저 로컬 스토리지(LocalStorage)에 자동**으로 저장하여, 새로고침 후에도 이전 상태 유지
- 💡 **왜 필요한가**
  - 사용자가 페이지를 새로고침하거나 브라우저를 닫았다 열어도 **상태가 유지됨**

#### 2. `immer` - 불변성 관리

- set 함수 안에서 마치 상태를 직접 수정 하듯 코드를 쓰면 내부적으로 불변성을 지켜주는 방식으로 처리한다.
- ✅ 장점:
  - 객체,배열을 복사해서 새로운 상태를 만드는 번거로움 감소
  - 불변성 위반 실수 예방
- ⚠️ 주의:
  - `zustand`에 내장되어 있지 않으므로 별도 설치 필요
  ```bash
  npm install immer
  ```

#### 3. devtools(연동)

- **Redux DevTools**와 연동하여 상태 변화 이력을 시각적으로 확인 가능
- 디버깅이나 상태 흐름 분석에 매우 유용

```jsx
import { devtools } from 'zustand/middleware';
```

---

### 📌 상태 흐름 예시 (with 미들웨어)

> 버튼 클릭 -> 상태 변경 요청
>
> > → 미들웨어 로직 실행 (예: 로깅, 저장, 검사 등)
>
> > → 상태 변경 완료

- 마치 HTTP 요청처럼:
  - 요청(request) -> 처리(핵심 로직) -> 응답(response)

---

## 🗃️ 번들이란?

> **번들(Bundle)** = 여러 개의 파일(모듈, 패키지 등)을 **하나의 파일로 합친것**  
> -> 브라우저가 더 빠르고 효율적으로 읽을 수 있도록 하기위해 하나의 파일로 합침

#### 🔍 예시 설명

1. `npm install axios` : Axios 라이브러리를 내 프로젝트에 설치
   - 파일은 `node_modules/axios` 폴더에 있지만 브라우저가 직접 읽는 건 아님
2. 그런데 이 상태 그대로 HTML에서 `<script src="axios.js">` 같은 걸 넣는 건 **불가능**
   - 브라우저는 CommonJS나 Node 방식으로 된 `node_modules` 폴더를 이해하지 못함
3. 그래서 Webpack, Vite 같은 번들러가:
   - `import axios from 'axios'` 한 것을 보고
   - 의존성 트리를 따라가서,
   - **axios + 작성한 코드 전체를 하나의 파일로 묶음**(bundle.js, index.js 등)
4. 이 묶인 파일을 **브라우저가 직접 실행**할 수 있다.
   - 코드 최적화, 압축(minify), 트리쉐이킹(tree shaking) 등도 이 과정에서 포함됨

#### ⚒️ 관련 용어

| 용어                           | 설명                                                |
| ------------------------------ | --------------------------------------------------- |
| 번들링 (Bundling)              | 여러 파일 → 하나의 실행 가능한 파일로 묶기          |
| 트리 쉐이킹 (Tree Shaking)     | 안 쓰는 코드를 번들에서 제거                        |
| 코드 스플리팅 (Code Splitting) | 앱을 여러 청크(chunk)로 나눠서 필요한 순간에만 로드 |
| 번들러 (Bundler)               | Webpack, Vite, esbuild 등이 대표적                  |

### ❓ 왜 번들이 필요한지?

> 브라우저는 **모듈 시스템도 없고, 수백개 파일을 한 번에 못 다루며, 네트워크 요청이 느리기 때문**

1. 네트워크 요청 최소화( 파일이 너무 많으면 HTTP 요청이 늘어나 페이지 로드가 느려진다)
2. 호환성 ( 최신 문법 ESM , jsx,타입스크립트등) 구형 브라우저에서 동작하도록 트랜스파일해서 묶어 준다.
3. 최적화 (코드 압축,코드 분할 )로 초기 로딩 속도와 실행 성능을 높인다.
